# 番茄钟应用详细设计文档

## 1. 引言

### 1.1 文档目的
本文档详细描述番茄钟应用的具体实现方案，包括组件结构、代码实现、数据流、API设计等，为开发团队提供详细的技术指导，确保开发的一致性和代码质量。

### 1.2 术语定义
- **组件**：React函数式组件，负责UI渲染和用户交互
- **Hook**：React Hooks，用于状态管理和副作用处理
- **Context**：React Context API，用于全局状态共享
- **服务**：封装业务逻辑的类或函数集合
- **Repository**：数据访问层，负责数据存储和检索

## 2. 项目结构

### 2.1 目录结构
```
src/
├── assets/              # 静态资源文件
│   ├── sounds/          # 音效文件
│   └── icons/           # 图标文件
├── components/          # 可复用UI组件
│   ├── common/          # 通用组件
│   ├── timer/           # 计时器相关组件
│   ├── tasks/           # 任务管理相关组件
│   ├── statistics/      # 统计分析相关组件
│   └── settings/        # 设置相关组件
├── context/             # React Context状态管理
│   ├── TimerContext.jsx
│   ├── TasksContext.jsx
│   └── SettingsContext.jsx
├── services/            # 业务逻辑服务
│   ├── TimerService.js
│   ├── TaskService.js
│   ├── StatisticsService.js
│   ├── NotificationService.js
│   └── StorageService.js
├── repositories/        # 数据访问层
│   ├── TaskRepository.js
│   ├── PomodoroRepository.js
│   └── SettingsRepository.js
├── utils/               # 工具函数
│   ├── dateUtils.js
│   ├── validationUtils.js
│   ├── formatUtils.js
│   └── constants.js
├── hooks/               # 自定义Hooks
│   ├── useTimer.js
│   ├── useTasks.js
│   └── useSettings.js
├── pages/               # 页面组件
│   ├── TimerPage.jsx
│   ├── TasksPage.jsx
│   ├── StatisticsPage.jsx
│   └── SettingsPage.jsx
├── App.jsx              # 应用入口组件
├── main.jsx             # 应用挂载点
└── index.css            # 全局样式
```

### 2.2 模块-文件映射

| 模块 | 主要文件 | 功能职责 |
|-----|---------|--------|
| 计时器模块 | src/components/timer/ | 实现计时UI和控制 |
| | src/context/TimerContext.jsx | 计时器状态管理 |
| | src/services/TimerService.js | 计时逻辑实现 |
| | src/hooks/useTimer.js | 计时器功能Hooks |
| 任务管理模块 | src/components/tasks/ | 任务管理UI实现 |
| | src/context/TasksContext.jsx | 任务状态管理 |
| | src/services/TaskService.js | 任务业务逻辑 |
| | src/repositories/TaskRepository.js | 任务数据访问 |
| 统计分析模块 | src/components/statistics/ | 统计图表UI实现 |
| | src/services/StatisticsService.js | 统计分析逻辑 |
| | src/repositories/PomodoroRepository.js | 番茄钟记录数据访问 |
| 设置模块 | src/components/settings/ | 设置界面UI实现 |
| | src/context/SettingsContext.jsx | 设置状态管理 |
| | src/repositories/SettingsRepository.js | 设置数据访问 |

## 3. 组件设计

### 3.1 基础UI组件

#### 3.1.1 Button组件
```jsx
// src/components/common/Button.jsx
import React from 'react';
import './Button.css';

const Button = ({ 
  variant = 'primary', 
  size = 'medium', 
  disabled = false, 
  onClick, 
  children, 
  className = '' 
}) => {
  const buttonClasses = `button button--${variant} button--${size} ${disabled ? 'button--disabled' : ''} ${className}`;
  
  return (
    <button
      className={buttonClasses}
      disabled={disabled}
      onClick={onClick}
    >
      {children}
    </button>
  );
};

export default Button;
```

#### 3.1.2 Modal组件
```jsx
// src/components/common/Modal.jsx
import React, { useEffect } from 'react';
import ReactDOM from 'react-dom';
import './Modal.css';

const Modal = ({ isOpen, onClose, title, children }) => {
  useEffect(() => {
    // 防止背景滚动
    if (isOpen) {
      document.body.style.overflow = 'hidden';
    }
    return () => {
      document.body.style.overflow = 'unset';
    };
  }, [isOpen]);

  if (!isOpen) return null;

  const handleOverlayClick = (e) => {
    if (e.target === e.currentTarget) {
      onClose();
    }
  };

  return ReactDOM.createPortal(
    <div className="modal-overlay" onClick={handleOverlayClick}>
      <div className="modal-content">
        <div className="modal-header">
          <h3 className="modal-title">{title}</h3>
          <button className="modal-close-button" onClick={onClose}>
            ×
          </button>
        </div>
        <div className="modal-body">
          {children}
        </div>
      </div>
    </div>,
    document.getElementById('modal-root')
  );
};

export default Modal;
```

### 3.2 计时器组件

#### 3.2.1 TimerDisplay组件
```jsx
// src/components/timer/TimerDisplay.jsx
import React from 'react';
import { useTimerContext } from '../../context/TimerContext';
import { formatTime } from '../../utils/formatUtils';
import './TimerDisplay.css';

const TimerDisplay = () => {
  const { state } = useTimerContext();
  const { timeRemaining, currentMode, status } = state;
  
  const modeLabels = {
    'pomodoro': '专注工作',
    'short-break': '短休息',
    'long-break': '长休息'
  };

  return (
    <div className={`timer-display timer-display--${currentMode} timer-display--${status}`}>
      <div className="timer-mode">{modeLabels[currentMode]}</div>
      <div className="timer-time">{formatTime(timeRemaining)}</div>
      <div className="timer-status">
        {status === 'running' ? '进行中...' : 
         status === 'paused' ? '已暂停' : 
         status === 'completed' ? '已完成' : '就绪'}
      </div>
    </div>
  );
};

export default TimerDisplay;
```

#### 3.2.2 TimerControls组件
```jsx
// src/components/timer/TimerControls.jsx
import React from 'react';
import { useTimerContext } from '../../context/TimerContext';
import Button from '../common/Button';
import './TimerControls.css';

const TimerControls = () => {
  const { state, startTimer, pauseTimer, resumeTimer, resetTimer, skipTimer } = useTimerContext();
  const { status, currentMode } = state;

  const handleAction = () => {
    switch (status) {
      case 'idle':
      case 'completed':
        startTimer(currentMode);
        break;
      case 'running':
        pauseTimer();
        break;
      case 'paused':
        resumeTimer();
        break;
      default:
        break;
    }
  };

  const getButtonText = () => {
    switch (status) {
      case 'idle':
      case 'completed':
        return '开始';
      case 'running':
        return '暂停';
      case 'paused':
        return '继续';
      default:
        return '开始';
    }
  };

  return (
    <div className="timer-controls">
      <Button 
        variant={status === 'running' ? 'warning' : 'primary'} 
        size="large" 
        onClick={handleAction}
      >
        {getButtonText()}
      </Button>
      {(status === 'running' || status === 'paused') && (
        <Button variant="secondary" size="medium" onClick={resetTimer}>
          重置
        </Button>
      )}
      {status === 'running' && (
        <Button variant="outline" size="medium" onClick={skipTimer}>
          跳过
        </Button>
      )}
    </div>
  );
};

export default TimerControls;
```

### 3.3 任务组件

#### 3.3.1 TaskList组件
```jsx
// src/components/tasks/TaskList.jsx
import React, { useEffect } from 'react';
import { useTasksContext } from '../../context/TasksContext';
import TaskItem from './TaskItem';
import './TaskList.css';

const TaskList = () => {
  const { tasks, loading, error, fetchTasks } = useTasksContext();

  useEffect(() => {
    fetchTasks();
  }, [fetchTasks]);

  if (loading) return <div className="task-list-loading">加载中...</div>;
  if (error) return <div className="task-list-error">错误: {error}</div>;

  return (
    <div className="task-list">
      {tasks.length === 0 ? (
        <div className="task-list-empty">暂无任务，添加一个新任务开始吧！</div>
      ) : (
        tasks.map(task => (
          <TaskItem key={task.id} task={task} />
        ))
      )}
    </div>
  );
};

export default TaskList;
```

#### 3.3.2 TaskForm组件
```jsx
// src/components/tasks/TaskForm.jsx
import React, { useState, useEffect } from 'react';
import { useTasksContext } from '../../context/TasksContext';
import Button from '../common/Button';
import './TaskForm.css';

const TaskForm = ({ initialTask = null, onClose }) => {
  const { createTask, updateTask } = useTasksContext();
  const [formData, setFormData] = useState({
    name: '',
    description: '',
    category: 'work',
    estimatedPomodoros: 1
  });

  useEffect(() => {
    if (initialTask) {
      setFormData({
        name: initialTask.name,
        description: initialTask.description || '',
        category: initialTask.category || 'work',
        estimatedPomodoros: initialTask.estimatedPomodoros
      });
    }
  }, [initialTask]);

  const handleSubmit = async (e) => {
    e.preventDefault();
    
    try {
      if (initialTask) {
        await updateTask({
          ...initialTask,
          ...formData,
          updatedAt: new Date()
        });
      } else {
        await createTask({
          ...formData,
          completedPomodoros: 0,
          isCompleted: false
        });
      }
      onClose();
    } catch (error) {
      console.error('保存任务失败:', error);
    }
  };

  const handleChange = (e) => {
    const { name, value } = e.target;
    setFormData(prev => ({
      ...prev,
      [name]: name === 'estimatedPomodoros' ? parseInt(value) || 1 : value
    }));
  };

  return (
    <form className="task-form" onSubmit={handleSubmit}>
      <div className="form-group">
        <label htmlFor="name">任务名称 *</label>
        <input
          type="text"
          id="name"
          name="name"
          value={formData.name}
          onChange={handleChange}
          required
          placeholder="输入任务名称"
        />
      </div>
      
      <div className="form-group">
        <label htmlFor="description">任务描述</label>
        <textarea
          id="description"
          name="description"
          value={formData.description}
          onChange={handleChange}
          placeholder="输入任务描述（可选）"
          rows={3}
        />
      </div>
      
      <div className="form-group">
        <label htmlFor="category">任务类别</label>
        <select
          id="category"
          name="category"
          value={formData.category}
          onChange={handleChange}
        >
          <option value="work">工作</option>
          <option value="study">学习</option>
          <option value="personal">个人</option>
          <option value="other">其他</option>
        </select>
      </div>
      
      <div className="form-group">
        <label htmlFor="estimatedPomodoros">预计番茄钟数量</label>
        <input
          type="number"
          id="estimatedPomodoros"
          name="estimatedPomodoros"
          value={formData.estimatedPomodoros}
          onChange={handleChange}
          min="1"
          max="100"
        />
      </div>
      
      <div className="form-actions">
        <Button type="button" variant="secondary" onClick={onClose}>
          取消
        </Button>
        <Button type="submit" variant="primary">
          {initialTask ? '更新任务' : '创建任务'}
        </Button>
      </div>
    </form>
  );
};

export default TaskForm;
```

## 4. 状态管理实现

### 4.1 TimerContext实现
```jsx
// src/context/TimerContext.jsx
import React, { createContext, useContext, useReducer, useEffect, useCallback } from 'react';
import TimerService from '../services/TimerService';
import { useSettingsContext } from './SettingsContext';
import { useTasksContext } from './TasksContext';
import { STORAGE_KEYS } from '../utils/constants';

const TimerContext = createContext();

// 初始状态
const initialState = {
  status: 'idle', // idle, running, paused, completed
  currentMode: 'pomodoro', // pomodoro, short-break, long-break
  timeRemaining: 25 * 60, // 默认25分钟，单位秒
  totalDuration: 25 * 60,
  completedPomodoros: 0,
  activeTaskId: null
};

// Action类型
const ACTIONS = {
  START_TIMER: 'START_TIMER',
  PAUSE_TIMER: 'PAUSE_TIMER',
  RESUME_TIMER: 'RESUME_TIMER',
  RESET_TIMER: 'RESET_TIMER',
  TICK: 'TICK',
  COMPLETE_TIMER: 'COMPLETE_TIMER',
  SWITCH_MODE: 'SWITCH_MODE',
  UPDATE_REMAINING_TIME: 'UPDATE_REMAINING_TIME',
  SET_ACTIVE_TASK: 'SET_ACTIVE_TASK',
  INCREMENT_POMODOROS: 'INCREMENT_POMODOROS'
};

// Reducer
const timerReducer = (state, action) => {
  switch (action.type) {
    case ACTIONS.START_TIMER:
      return {
        ...state,
        status: 'running',
        timeRemaining: action.payload.duration,
        totalDuration: action.payload.duration
      };
    case ACTIONS.PAUSE_TIMER:
      return {
        ...state,
        status: 'paused'
      };
    case ACTIONS.RESUME_TIMER:
      return {
        ...state,
        status: 'running'
      };
    case ACTIONS.RESET_TIMER:
      return {
        ...state,
        status: 'idle',
        timeRemaining: state.totalDuration
      };
    case ACTIONS.TICK:
      return {
        ...state,
        timeRemaining: Math.max(0, state.timeRemaining - 1)
      };
    case ACTIONS.COMPLETE_TIMER:
      return {
        ...state,
        status: 'completed',
        timeRemaining: 0
      };
    case ACTIONS.SWITCH_MODE:
      return {
        ...state,
        currentMode: action.payload.mode,
        timeRemaining: action.payload.duration,
        totalDuration: action.payload.duration,
        status: 'idle'
      };
    case ACTIONS.SET_ACTIVE_TASK:
      return {
        ...state,
        activeTaskId: action.payload.taskId
      };
    case ACTIONS.INCREMENT_POMODOROS:
      return {
        ...state,
        completedPomodoros: state.completedPomodoros + 1
      };
    default:
      return state;
  }
};

export const TimerProvider = ({ children }) => {
  const [state, dispatch] = useReducer(timerReducer, initialState);
  const { settings } = useSettingsContext();
  const { updateTask } = useTasksContext();
  const timerService = new TimerService();

  // 保存和恢复状态
  useEffect(() => {
    const savedState = localStorage.getItem(STORAGE_KEYS.TIMER_STATE);
    if (savedState) {
      const parsed = JSON.parse(savedState);
      // 恢复状态逻辑
    }
  }, []);

  useEffect(() => {
    // 保存状态到localStorage
    if (state.status !== 'running') {
      localStorage.setItem(STORAGE_KEYS.TIMER_STATE, JSON.stringify(state));
    }
  }, [state]);

  // 开始计时器
  const startTimer = useCallback((mode = state.currentMode) => {
    const durationMap = {
      'pomodoro': settings.timer.pomodoroDuration * 60,
      'short-break': settings.timer.shortBreakDuration * 60,
      'long-break': settings.timer.longBreakDuration * 60
    };

    dispatch({
      type: ACTIONS.START_TIMER,
      payload: { duration: durationMap[mode] }
    });

    timerService.start(() => {
      dispatch({ type: ACTIONS.TICK });
    }, () => {
      handleTimerComplete();
    });
  }, [settings, timerService]);

  // 计时器完成处理
  const handleTimerComplete = useCallback(async () => {
    dispatch({ type: ACTIONS.COMPLETE_TIMER });
    
    // 播放提醒音效
    // NotificationService.showNotification(...);

    // 如果是番茄钟完成，增加计数并更新任务
    if (state.currentMode === 'pomodoro') {
      dispatch({ type: ACTIONS.INCREMENT_POMODOROS });
      
      if (state.activeTaskId) {
        // 更新任务的已完成番茄钟数
        // updateTask逻辑...
      }

      // 记录番茄钟历史
      // PomodoroRepository.create(...);
    }

    // 自动进入下一阶段
    setTimeout(() => {
      if (state.currentMode === 'pomodoro') {
        // 检查是否需要长休息
        const shouldTakeLongBreak = (state.completedPomodoros + 1) % settings.timer.longBreakInterval === 0;
        const nextMode = shouldTakeLongBreak ? 'long-break' : 'short-break';
        dispatch({
          type: ACTIONS.SWITCH_MODE,
          payload: {
            mode: nextMode,
            duration: settings.timer[nextMode === 'long-break' ? 'longBreakDuration' : 'shortBreakDuration'] * 60
          }
        });
      } else {
        // 休息结束，回到番茄钟模式
        dispatch({
          type: ACTIONS.SWITCH_MODE,
          payload: {
            mode: 'pomodoro',
            duration: settings.timer.pomodoroDuration * 60
          }
        });
      }
    }, 3000);
  }, [state, settings]);

  // 其他方法：暂停、继续、重置、跳过
  const pauseTimer = useCallback(() => {
    dispatch({ type: ACTIONS.PAUSE_TIMER });
    timerService.pause();
  }, [timerService]);

  const resumeTimer = useCallback(() => {
    dispatch({ type: ACTIONS.RESUME_TIMER });
    timerService.resume();
  }, [timerService]);

  const resetTimer = useCallback(() => {
    dispatch({ type: ACTIONS.RESET_TIMER });
    timerService.reset();
  }, [timerService]);

  const skipTimer = useCallback(() => {
    timerService.reset();
    handleTimerComplete();
  }, [timerService, handleTimerComplete]);

  const setActiveTask = useCallback((taskId) => {
    dispatch({ type: ACTIONS.SET_ACTIVE_TASK, payload: { taskId } });
  }, []);

  const value = {
    state,
    startTimer,
    pauseTimer,
    resumeTimer,
    resetTimer,
    skipTimer,
    setActiveTask
  };

  return (
    <TimerContext.Provider value={value}>
      {children}
    </TimerContext.Provider>
  );
};

export const useTimerContext = () => {
  const context = useContext(TimerContext);
  if (!context) {
    throw new Error('useTimerContext must be used within a TimerProvider');
  }
  return context;
};
```

## 5. 服务层实现

### 5.1 TimerService实现
```javascript
// src/services/TimerService.js
class TimerService {
  constructor() {
    this.timerId = null;
    this.isRunning = false;
    this.tickCallback = null;
    this.completeCallback = null;
  }

  // 开始计时
  start(tickCallback, completeCallback) {
    this.tickCallback = tickCallback;
    this.completeCallback = completeCallback;
    this.isRunning = true;
    
    // 使用Web Worker进行计时，避免UI线程阻塞
    if (window.Worker) {
      this.worker = new Worker('/timer-worker.js');
      this.worker.onmessage = (e) => {
        if (e.data.type === 'tick') {
          this.tickCallback();
        }
      };
    } else {
      // 降级方案：使用setInterval
      this.startInterval();
    }
  }

  // 暂停计时
  pause() {
    this.isRunning = false;
    if (this.worker) {
      this.worker.postMessage({ action: 'pause' });
    } else {
      this.clearInterval();
    }
  }

  // 继续计时
  resume() {
    this.isRunning = true;
    if (this.worker) {
      this.worker.postMessage({ action: 'resume' });
    } else {
      this.startInterval();
    }
  }

  // 重置计时
  reset() {
    this.isRunning = false;
    if (this.worker) {
      this.worker.terminate();
      this.worker = null;
    } else {
      this.clearInterval();
    }
  }

  // 开始interval计时（降级方案）
  startInterval() {
    this.timerId = setInterval(() => {
      if (this.isRunning && this.tickCallback) {
        this.tickCallback();
      }
    }, 1000);
  }

  // 清除interval
  clearInterval() {
    if (this.timerId) {
      clearInterval(this.timerId);
      this.timerId = null;
    }
  }

  // 通知完成
  notifyComplete() {
    if (this.completeCallback) {
      this.completeCallback();
    }
  }

  // 销毁
  destroy() {
    this.reset();
    this.tickCallback = null;
    this.completeCallback = null;
  }
}

export default TimerService;
```

### 5.2 StorageService实现
```javascript
// src/services/StorageService.js
class StorageService {
  constructor() {
    this.isSupported = this.checkSupport();
  }

  // 检查存储支持
  checkSupport() {
    try {
      const testKey = '__storage_test__';
      localStorage.setItem(testKey, testKey);
      localStorage.removeItem(testKey);
      return true;
    } catch (e) {
      return false;
    }
  }

  // 保存数据
  save(key, data) {
    if (!this.isSupported) {
      console.warn('localStorage is not supported');
      return false;
    }

    try {
      const serializedData = JSON.stringify(data);
      localStorage.setItem(key, serializedData);
      return true;
    } catch (error) {
      console.error('Error saving to localStorage:', error);
      return false;
    }
  }

  // 获取数据
  get(key) {
    if (!this.isSupported) {
      return null;
    }

    try {
      const serializedData = localStorage.getItem(key);
      if (serializedData === null) {
        return null;
      }
      return JSON.parse(serializedData);
    } catch (error) {
      console.error('Error reading from localStorage:', error);
      return null;
    }
  }

  // 删除数据
  remove(key) {
    if (!this.isSupported) {
      return false;
    }

    try {
      localStorage.removeItem(key);
      return true;
    } catch (error) {
      console.error('Error removing from localStorage:', error);
      return false;
    }
  }

  // 清空所有数据
  clear() {
    if (!this.isSupported) {
      return false;
    }

    try {
      localStorage.clear();
      return true;
    } catch (error) {
      console.error('Error clearing localStorage:', error);
      return false;
    }
  }

  // 批量保存
  saveMultiple(items) {
    if (!Array.isArray(items)) {
      return false;
    }

    return items.every(({ key, data }) => this.save(key, data));
  }

  // 批量获取
  getMultiple(keys) {
    if (!Array.isArray(keys)) {
      return {};
    }

    const result = {};
    keys.forEach(key => {
      result[key] = this.get(key);
    });
    return result;
  }

  // 检查是否存在
  exists(key) {
    return this.get(key) !== null;
  }

  // 获取所有键
  getAllKeys() {
    if (!this.isSupported) {
      return [];
    }

    const keys = [];
    for (let i = 0; i < localStorage.length; i++) {
      keys.push(localStorage.key(i));
    }
    return keys;
  }

  // 获取存储大小（字节）
  getStorageSize() {
    if (!this.isSupported) {
      return 0;
    }

    let size = 0;
    for (let key in localStorage) {
      if (localStorage.hasOwnProperty(key)) {
        size += localStorage[key].length + key.length;
      }
    }
    return size;
  }
}

export default new StorageService();
```

## 6. 数据访问层实现

### 6.1 TaskRepository实现
```javascript
// src/repositories/TaskRepository.js
import StorageService from '../services/StorageService';
import { STORAGE_KEYS } from '../utils/constants';
import { generateId } from '../utils/formatUtils';

class TaskRepository {
  constructor() {
    this.storageKey = STORAGE_KEYS.TASKS;
  }

  // 获取所有任务
  async getAll() {
    try {
      const tasks = StorageService.get(this.storageKey) || [];
      return tasks.map(task => ({
        ...task,
        createdAt: new Date(task.createdAt),
        updatedAt: new Date(task.updatedAt)
      }));
    } catch (error) {
      console.error('Error fetching tasks:', error);
      return [];
    }
  }

  // 根据ID获取任务
  async getById(id) {
    try {
      const tasks = await this.getAll();
      const task = tasks.find(t => t.id === id);
      return task || null;
    } catch (error) {
      console.error(`Error fetching task with id ${id}:`, error);
      return null;
    }
  }

  // 创建任务
  async create(taskData) {
    try {
      const tasks = await this.getAll();
      const newTask = {
        id: generateId(),
        ...taskData,
        createdAt: new Date(),
        updatedAt: new Date()
      };
      
      tasks.push(newTask);
      StorageService.save(this.storageKey, tasks);
      return newTask;
    } catch (error) {
      console.error('Error creating task:', error);
      throw error;
    }
  }

  // 更新任务
  async update(updatedTask) {
    try {
      const tasks = await this.getAll();
      const taskIndex = tasks.findIndex(t => t.id === updatedTask.id);
      
      if (taskIndex === -1) {
        throw new Error(`Task with id ${updatedTask.id} not found`);
      }
      
      tasks[taskIndex] = {
        ...updatedTask,
        updatedAt: new Date()
      };
      
      StorageService.save(this.storageKey, tasks);
      return tasks[taskIndex];
    } catch (error) {
      console.error(`Error updating task with id ${updatedTask.id}:`, error);
      throw error;
    }
  }

  // 删除任务
  async delete(id) {
    try {
      const tasks = await this.getAll();
      const filteredTasks = tasks.filter(t => t.id !== id);
      
      if (filteredTasks.length === tasks.length) {
        throw new Error(`Task with id ${id} not found`);
      }
      
      StorageService.save(this.storageKey, filteredTasks);
    } catch (error) {
      console.error(`Error deleting task with id ${id}:`, error);
      throw error;
    }
  }

  // 根据类别获取任务
  async getByCategory(category) {
    try {
      const tasks = await this.getAll();
      return tasks.filter(t => t.category === category);
    } catch (error) {
      console.error(`Error fetching tasks by category ${category}:`, error);
      return [];
    }
  }

  // 获取未完成任务
  async getIncomplete() {
    try {
      const tasks = await this.getAll();
      return tasks.filter(t => !t.isCompleted);
    } catch (error) {
      console.error('Error fetching incomplete tasks:', error);
      return [];
    }
  }

  // 获取已完成任务
  async getCompleted() {
    try {
      const tasks = await this.getAll();
      return tasks.filter(t => t.isCompleted);
    } catch (error) {
      console.error('Error fetching completed tasks:', error);
      return [];
    }
  }

  // 清空所有任务
  async clearAll() {
    try {
      StorageService.save(this.storageKey, []);
    } catch (error) {
      console.error('Error clearing all tasks:', error);
      throw error;
    }
  }

  // 批量导入任务
  async importTasks(tasks) {
    try {
      // 为导入的任务生成新ID和时间戳
      const importedTasks = tasks.map(task => ({
        ...task,
        id: generateId(),
        createdAt: new Date(),
        updatedAt: new Date()
      }));
      
      StorageService.save(this.storageKey, importedTasks);
      return importedTasks;
    } catch (error) {
      console.error('Error importing tasks:', error);
      throw error;
    }
  }
}

export default new TaskRepository();
```

## 7. 工具函数实现

### 7.1 formatUtils.js
```javascript
// src/utils/formatUtils.js

// 格式化时间（秒转换为 mm:ss 格式）
export const formatTime = (seconds) => {
  const mins = Math.floor(seconds / 60);
  const secs = seconds % 60;
  return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
};

// 生成唯一ID
export const generateId = () => {
  return Date.now().toString(36) + Math.random().toString(36).substr(2, 5);
};

// 格式化日期
export const formatDate = (date) => {
  const d = new Date(date);
  const year = d.getFullYear();
  const month = (d.getMonth() + 1).toString().padStart(2, '0');
  const day = d.getDate().toString().padStart(2, '0');
  return `${year}-${month}-${day}`;
};

// 格式化日期时间
export const formatDateTime = (date) => {
  const d = new Date(date);
  const dateStr = formatDate(d);
  const hours = d.getHours().toString().padStart(2, '0');
  const minutes = d.getMinutes().toString().padStart(2, '0');
  return `${dateStr} ${hours}:${minutes}`;
};

// 获取星期几文本
export const getDayOfWeek = (date) => {
  const days = ['周日', '周一', '周二', '周三', '周四', '周五', '周六'];
  const d = new Date(date);
  return days[d.getDay()];
};

// 计算两个日期之间的天数
export const daysBetween = (date1, date2) => {
  const oneDay = 24 * 60 * 60 * 1000;
  const d1 = new Date(date1);
  const d2 = new Date(date2);
  return Math.round(Math.abs((d1 - d2) / oneDay));
};

// 截断文本
export const truncateText = (text, maxLength = 50) => {
  if (!text || text.length <= maxLength) return text;
  return text.substring(0, maxLength) + '...';
};

// 格式化数字（添加千位分隔符）
export const formatNumber = (num) => {
  return num.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ',');
};
```

### 7.2 constants.js
```javascript
// src/utils/constants.js

// 存储键名
export const STORAGE_KEYS = {
  TASKS: 'pomodoro_tasks',
  POMODORO_RECORDS: 'pomodoro_records',
  USER_SETTINGS: 'pomodoro_settings',
  TIMER_STATE: 'pomodoro_timer_state',
  APP_STATE: 'pomodoro_app_state'
};

// 默认设置
export const DEFAULT_SETTINGS = {
  timer: {
    pomodoroDuration: 25,
    shortBreakDuration: 5,
    longBreakDuration: 15,
    longBreakInterval: 4
  },
  notifications: {
    soundEnabled: true,
    volume: 70,
    soundType: 'bell',
    visualNotification: true
  },
  appearance: {
    theme: 'light',
    fontSize: 'medium'
  },
  language: 'zh-CN'
};

// 任务类别
export const TASK_CATEGORIES = [
  { value: 'work', label: '工作', color: '#3b82f6' },
  { value: 'study', label: '学习', color: '#10b981' },
  { value: 'personal', label: '个人', color: '#f59e0b' },
  { value: 'other', label: '其他', color: '#6b7280' }
];

// 音效类型
export const SOUND_TYPES = [
  { value: 'bell', label: '铃声' },
  { value: 'chime', label: '风铃' },
  { value: 'notification', label: '通知' },
  { value: 'birds', label: '鸟鸣' },
  { value: 'none', label: '无' }
];

// 主题选项
export const THEME_OPTIONS = [
  { value: 'light', label: '浅色' },
  { value: 'dark', label: '深色' },
  { value: 'system', label: '跟随系统' }
];

// 字体大小选项
export const FONT_SIZE_OPTIONS = [
  { value: 'small', label: '小' },
  { value: 'medium', label: '中' },
  { value: 'large', label: '大' }
];

// 错误消息
export const ERROR_MESSAGES = {
  TASK_NOT_FOUND: '任务不存在',
  STORAGE_ERROR: '存储操作失败',
  NETWORK_ERROR: '网络连接错误',
  INVALID_INPUT: '输入数据无效',
  TIMER_ERROR: '计时器错误'
};

// 成功消息
export const SUCCESS_MESSAGES = {
  TASK_CREATED: '任务创建成功',
  TASK_UPDATED: '任务更新成功',
  TASK_DELETED: '任务删除成功',
  SETTINGS_SAVED: '设置保存成功',
  DATA_EXPORTED: '数据导出成功',
  DATA_IMPORTED: '数据导入成功'
};
```

## 8. 应用入口和路由

### 8.1 main.jsx
```jsx
// src/main.jsx
import React from 'react'
import ReactDOM from 'react-dom/client'
import App from './App.jsx'
import { TimerProvider } from './context/TimerContext.jsx'
import { TasksProvider } from './context/TasksContext.jsx'
import { SettingsProvider } from './context/SettingsContext.jsx'
import './index.css'

// 创建一个modal-root元素用于模态框挂载
const modalRoot = document.createElement('div')
modalRoot.id = 'modal-root'
document.body.appendChild(modalRoot)

ReactDOM.createRoot(document.getElementById('root')).render(
  <React.StrictMode>
    <SettingsProvider>
      <TasksProvider>
        <TimerProvider>
          <App />
        </TimerProvider>
      </TasksProvider>
    </SettingsProvider>
  </React.StrictMode>,
)
```

### 8.2 App.jsx
```jsx
// src/App.jsx
import React, { useEffect } from 'react'
import { BrowserRouter as Router, Routes, Route, Navigate } from 'react-router-dom'
import TimerPage from './pages/TimerPage'
import TasksPage from './pages/TasksPage'
import StatisticsPage from './pages/StatisticsPage'
import SettingsPage from './pages/SettingsPage'
import Navbar from './components/common/Navbar'
import { useSettingsContext } from './context/SettingsContext'
import './App.css'

function App() {
  const { settings } = useSettingsContext()

  // 应用主题
  useEffect(() => {
    const applyTheme = () => {
      if (settings.appearance.theme === 'system') {
        const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches
        document.documentElement.classList.toggle('dark', prefersDark)
      } else {
        document.documentElement.classList.toggle('dark', settings.appearance.theme === 'dark')
      }
    }

    applyTheme()
    
    // 监听系统主题变化
    const mediaQuery = window.matchMedia('(prefers-color-scheme: dark)')
    mediaQuery.addEventListener('change', applyTheme)
    
    return () => {
      mediaQuery.removeEventListener('change', applyTheme)
    }
  }, [settings.appearance.theme])

  // 应用字体大小
  useEffect(() => {
    document.documentElement.style.fontSize = {
      small: '0.875rem',
      medium: '1rem',
      large: '1.125rem'
    }[settings.appearance.fontSize]
  }, [settings.appearance.fontSize])

  return (
    <Router>
      <div className="app">
        <Navbar />
        <main className="main-content">
          <Routes>
            <Route path="/" element={<TimerPage />} />
            <Route path="/tasks" element={<TasksPage />} />
            <Route path="/statistics" element={<StatisticsPage />} />
            <Route path="/settings" element={<SettingsPage />} />
            <Route path="*" element={<Navigate to="/" replace />} />
          </Routes>
        </main>
      </div>
    </Router>
  )
}

export default App
```

## 9. 样式设计

### 9.1 CSS变量定义
```css
/* src/index.css */
:root {
  /* 浅色主题变量 */
  --color-bg-primary: #ffffff;
  --color-bg-secondary: #f3f4f6;
  --color-bg-tertiary: #e5e7eb;
  --color-text-primary: #111827;
  --color-text-secondary: #4b5563;
  --color-text-tertiary: #9ca3af;
  --color-border: #d1d5db;
  --color-accent-primary: #3b82f6;
  --color-accent-secondary: #10b981;
  --color-accent-warning: #f59e0b;
  --color-accent-danger: #ef4444;
  --color-pomodoro: #ef4444;
  --color-short-break: #3b82f6;
  --color-long-break: #10b981;
  
  /* 间距变量 */
  --spacing-xs: 0.25rem;
  --spacing-sm: 0.5rem;
  --spacing-md: 1rem;
  --spacing-lg: 1.5rem;
  --spacing-xl: 2rem;
  
  /* 圆角变量 */
  --radius-sm: 0.25rem;
  --radius-md: 0.5rem;
  --radius-lg: 1rem;
  --radius-full: 9999px;
  
  /* 阴影变量 */
  --shadow-sm: 0 1px 2px 0 rgba(0, 0, 0, 0.05);
  --shadow-md: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
  --shadow-lg: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
  
  /* 过渡变量 */
  --transition-fast: 0.15s ease-in-out;
  --transition-normal: 0.3s ease-in-out;
}

/* 深色主题变量 */
.dark {
  --color-bg-primary: #111827;
  --color-bg-secondary: #1f2937;
  --color-bg-tertiary: #374151;
  --color-text-primary: #f3f4f6;
  --color-text-secondary: #d1d5db;
  --color-text-tertiary: #9ca3af;
  --color-border: #4b5563;
  --color-accent-primary: #60a5fa;
  --color-accent-secondary: #34d399;
  --color-accent-warning: #fbbf24;
  --color-accent-danger: #f87171;
}

/* 基础重置 */
* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

body {
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen',
    'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue',
    sans-serif;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  background-color: var(--color-bg-primary);
  color: var(--color-text-primary);
  transition: background-color var(--transition-normal), color var(--transition-normal);
}

/* 应用容器 */
.app {
  min-height: 100vh;
  display: flex;
  flex-direction: column;
}

.main-content {
  flex: 1;
  padding: var(--spacing-md);
  max-width: 1200px;
  margin: 0 auto;
  width: 100%;
}

/* 响应式调整 */
@media (max-width: 768px) {
  .main-content {
    padding: var(--spacing-sm);
  }
}
```

## 10. 性能优化和最佳实践

### 10.1 性能优化策略

#### 10.1.1 组件懒加载
```jsx
// src/App.jsx (优化版)
import React, { lazy, Suspense } from 'react'

// 懒加载页面组件
const TimerPage = lazy(() => import('./pages/TimerPage'))
const TasksPage = lazy(() => import('./pages/TasksPage'))
const StatisticsPage = lazy(() => import('./pages/StatisticsPage'))
const SettingsPage = lazy(() => import('./pages/SettingsPage'))

// 在路由中使用
<Suspense fallback={<div>加载中...</div>}>
  <Routes>
    <Route path="/" element={<TimerPage />} />
    <Route path="/tasks" element={<TasksPage />} />
    <Route path="/statistics" element={<StatisticsPage />} />
    <Route path="/settings" element={<SettingsPage />} />
  </Routes>
</Suspense>
```

#### 10.1.2 使用Web Worker进行计时
```javascript
// public/timer-worker.js
let timerId = null;
let isPaused = false;

self.onmessage = (e) => {
  if (e.data.action === 'pause') {
    isPaused = true;
    if (timerId) {
      clearInterval(timerId);
      timerId = null;
    }
  } else if (e.data.action === 'resume') {
    isPaused = false;
    startTimer();
  }
};

function startTimer() {
  if (timerId) return;
  
  timerId = setInterval(() => {
    if (!isPaused) {
      self.postMessage({ type: 'tick' });
    }
  }, 1000);
}

// 初始启动
startTimer();
```

#### 10.1.3 避免不必要的重渲染
```jsx
// 使用React.memo优化组件
const TaskItem = React.memo(({ task, onEdit, onDelete, onComplete }) => {
  // 组件逻辑...
});

// 使用useMemo缓存计算结果
const filteredTasks = useMemo(() => {
  return tasks.filter(task => {
    if (filter.category && task.category !== filter.category) return false;
    if (filter.isCompleted !== undefined && task.isCompleted !== filter.isCompleted) return false;
    return true;
  });
}, [tasks, filter]);

// 使用useCallback缓存回调函数
const handleTaskEdit = useCallback((task) => {
  setEditingTask(task);
  setIsModalOpen(true);
}, []);
```

### 10.2 代码质量和最佳实践

#### 10.2.1 错误边界实现
```jsx
// src/components/common/ErrorBoundary.jsx
import React, { Component } from 'react';

class ErrorBoundary extends Component {
  constructor(props) {
    super(props);
    this.state = { hasError: false, error: null };
  }

  static getDerivedStateFromError(error) {
    return { hasError: true, error };
  }

  componentDidCatch(error, errorInfo) {
    console.error('Error caught by ErrorBoundary:', error, errorInfo);
  }

  render() {
    if (this.state.hasError) {
      return (
        <div className="error-boundary">
          <h2>出错了</h2>
          <p>{this.state.error?.toString()}</p>
          <button onClick={() => this.setState({ hasError: false })}>
            重试
          </button>
        </div>
      );
    }

    return this.props.children;
  }
}

export default ErrorBoundary;
```

#### 10.2.2 数据验证
```javascript
// src/utils/validationUtils.js
export const validateTask = (task) => {
  const errors = {};
  
  if (!task.name || task.name.trim() === '') {
    errors.name = '任务名称不能为空';
  } else if (task.name.length > 100) {
    errors.name = '任务名称不能超过100个字符';
  }
  
  if (task.description && task.description.length > 500) {
    errors.description = '任务描述不能超过500个字符';
  }
  
  if (task.estimatedPomodoros && (task.estimatedPomodoros < 1 || task.estimatedPomodoros > 100)) {
    errors.estimatedPomodoros = '预计番茄钟数量必须在1-100之间';
  }
  
  return {
    isValid: Object.keys(errors).length === 0,
    errors
  };
};

export const validateSettings = (settings) => {
  const errors = {};
  
  // 验证计时器设置
  if (settings.timer) {
    if (settings.timer.pomodoroDuration < 1 || settings.timer.pomodoroDuration > 60) {
      errors.pomodoroDuration = '番茄钟时长必须在1-60分钟之间';
    }
    if (settings.timer.shortBreakDuration < 1 || settings.timer.shortBreakDuration > 30) {
      errors.shortBreakDuration = '短休息时长必须在1-30分钟之间';
    }
    if (settings.timer.longBreakDuration < 5 || settings.timer.longBreakDuration > 60) {
      errors.longBreakDuration = '长休息时长必须在5-60分钟之间';
    }
    if (settings.timer.longBreakInterval < 1 || settings.timer.longBreakInterval > 10) {
      errors.longBreakInterval = '长休息间隔必须在1-10个番茄钟之间';
    }
  }
  
  return {
    isValid: Object.keys(errors).length === 0,
    errors
  };
};
```

---

**文档版本**：V1.0.0  
**创建日期**：2024年1月  
**更新日期**：2024年1月